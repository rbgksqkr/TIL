# --- 문제 분석 ---
# 랭킹 리스트가 비오름차순으로 저장
# 위에서부터 몇 번째 있는 점수인지로 등수 결정
# 같은 점수일 땐 동률로 인지
# 100, 90, 90, 80 -> 1, 2, 2, 4 등
# 랭킹 리스트에 올라갈 수 있는 점수의 개수 P
# N개의 점수가 비오름차순으로 저장
# 랭킹 리스트가 꽉 차있을 때, 새 점수가 이전 점수보다 더 좋을 때만 점수가 바뀐다.
# TODO: 태수의 새로운 점수가 랭킹 리스트에서 몇 등인지 출력

# --- 문제 풀이 ---
# N, 태수 점수, 점수의 개수 P


# 첫째 줄에 N, 태수의 새로운 점수, 그리고 P가 주어진다.
# P는 10보다 크거나 같고, 50보다 작거나 같은 정수, N은 0보다 크거나 같고, P보다 작거나 같은 정수이다.
# 그리고 모든 점수는 2,000,000,000보다 작거나 같은 자연수 또는 0이다. 둘째 줄에는 현재 랭킹 리스트에 있는 점수가 비오름차순으로 주어진다.
# 둘째 줄은 N이 0보다 큰 경우에만 주어진다.

# 3 90 10
# 100 90 80

# 1. scores 내림차순 정렬
# 2. target과 같은 값을 만나면 인덱스값을 print
# 3. p만큼 돌았는데 같은 값 찾아서 갖고 있다가 다른 값을 만나면 출력 (새 점수가 이전 점수보다 더 좋을 때만 점수 갱신)

import sys
input = sys.stdin.readline

n, target, p = map(int, input().split())

if n == 0: # n이 0일 때 랭크는 1
    print(1)
else:
    scores = list(map(int, input().split()))
    if n == p and scores[n-1] >= target: # 점수 개수와 랭크 개수가 같을 때, 최소값이 target보다 크거나 같으면 갱신이 안되므로 -1
        print(-1)
    else: # n과 p가 다르다 == n보다 p가 크다
        res = n + 1
        for i in range(n): 
            if target >= scores[i]:
                res = i+1
                break
        print(res)
